<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP缓存 | Yellow的博客</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="专注 Node.js 技术栈分享，从前端到Node.js再到数据库">
    <link rel="preload" href="/assets/css/0.styles.ad1b0c17.css" as="style"><link rel="preload" href="/assets/js/app.7a7e6d7d.js" as="script"><link rel="preload" href="/assets/js/2.3e29c34d.js" as="script"><link rel="preload" href="/assets/js/8.13f8e95d.js" as="script"><link rel="prefetch" href="/assets/js/10.0f374b69.js"><link rel="prefetch" href="/assets/js/11.8a9e5b86.js"><link rel="prefetch" href="/assets/js/12.b5963a33.js"><link rel="prefetch" href="/assets/js/13.9f01a3c7.js"><link rel="prefetch" href="/assets/js/14.cb6ba9c6.js"><link rel="prefetch" href="/assets/js/15.47cb4fd4.js"><link rel="prefetch" href="/assets/js/16.3cdca8ac.js"><link rel="prefetch" href="/assets/js/17.bf18c0d9.js"><link rel="prefetch" href="/assets/js/18.01c02710.js"><link rel="prefetch" href="/assets/js/19.1fc08694.js"><link rel="prefetch" href="/assets/js/20.d1756e82.js"><link rel="prefetch" href="/assets/js/3.dacd1a03.js"><link rel="prefetch" href="/assets/js/4.ee169d2f.js"><link rel="prefetch" href="/assets/js/5.4237fbf4.js"><link rel="prefetch" href="/assets/js/6.80092b82.js"><link rel="prefetch" href="/assets/js/7.ee84d0fe.js"><link rel="prefetch" href="/assets/js/9.46f5da93.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ad1b0c17.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Yellow的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://github.com/Arsenal072" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://github.com/Arsenal072" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/basic/" class="sidebar-link">知识图谱</a></li><li><a href="/css/" class="sidebar-link">CSS</a></li><li><section class="sidebar-group depth-0"><a href="/js/" class="sidebar-heading clickable"><span>js基础</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/eventloop.html" class="sidebar-link">事件循环</a></li><li><a href="/js/module.html" class="sidebar-link">模块化</a></li><li><a href="/js/asynchronous.html" class="sidebar-link">异步编程</a></li><li><a href="/js/handle.html" class="sidebar-link">手写</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/browser/" class="sidebar-heading clickable router-link-active open"><span>浏览器相关</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser/crossDomain.html" class="sidebar-link">跨域</a></li><li><a href="/browser/cache.html" aria-current="page" class="active sidebar-link">缓存</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/vue/" class="sidebar-heading clickable"><span>Vue源码</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/compile.html" class="sidebar-link">编译器</a></li><li><a href="/vue/vdom.html" class="sidebar-link">vdom</a></li><li><a href="/vue/vuex.html" class="sidebar-link">vuex</a></li><li><a href="/vue/vueRouter.html" class="sidebar-link">vue-router</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h4 id="http缓存"><a href="#http缓存" class="header-anchor">#</a> HTTP缓存</h4> <h4 id="使用http缓存的意义"><a href="#使用http缓存的意义" class="header-anchor">#</a> 使用HTTP缓存的意义</h4> <p>为什么要使用缓存，是因为缓存可以提高性能和用户体验</p> <ul><li>减少了冗余的数据传递，节省宽带流量</li> <li>减少了服务器的负担，大大提高了网站性能</li> <li>加快了网页加载速度 这也正是HTTP缓存属于客户端缓存的原因。</li></ul> <h4 id="缓存存储位置"><a href="#缓存存储位置" class="header-anchor">#</a> 缓存存储位置</h4> <p>缓存的储存是内存和磁盘两个位置，由当前浏览器本身的策略决定，比较随机，从内存的缓存中取出的数据会显示 (from memory cache)，从磁盘的缓存中取出的数据会显示 (from disk cache)</p> <ul><li>存放到memory内存中的资源，当关闭页面时,此资源就会被内存释放掉,再次重新打开相同的页面时,不会出现from memory cache的情况。而存放到disk磁盘中的资源不会随着该页面的关闭而释放掉,因为是存在硬盘中的,下次打开仍然会是from disk cache</li> <li>一般脚本、字体、图片会存在memory内存当中，一般非脚本会存在disk内存当中，如css等。</li></ul> <h4 id="http缓存分类"><a href="#http缓存分类" class="header-anchor">#</a> HTTP缓存分类</h4> <p>包括：强制缓存和协商缓存</p> <h4 id="强制缓存和协商缓存区别"><a href="#强制缓存和协商缓存区别" class="header-anchor">#</a> 强制缓存和协商缓存区别</h4> <ul><li><p>协商缓存每次请求都需要跟服务器通信，验证本地缓存是否依旧有效，最终确定是否使用本地缓存</p></li> <li><p>强制缓存命中缓存，服务器返回状态码是 200，而协商缓存命中缓存，服务器返回状态码是 304</p> <p><img src="C:/Users/ucmed/Desktop/1598968226825.png" alt="1598968226825"></p></li></ul> <h4 id="强制缓存"><a href="#强制缓存" class="header-anchor">#</a> 强制缓存</h4> <p>强制缓存是第一次访问服务器获取数据后，在有效时间内不会再请求服务器，而是直接使用缓存数据</p> <p>对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control</p> <p><img src="C:/Users/ucmed/Desktop/1598968300239.png" alt="1598968300239"></p> <h5 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h5> <p>在 HTTP 1.0 版本，服务器使用的响应头字段为 Expires，Exprires的值为服务端返回的数据到期时间**(绝对时间)**。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。</p> <h5 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h5> <p>Cache-Control有很多属性，不同的属性代表的意义也不同。</p> <ul><li>private：客户端可以缓存</li> <li>public：客户端和代理服务器都可以缓存</li> <li>max-age=t：缓存内容将在t秒后失效</li> <li>no-cache：需要使用协商缓存来验证缓存数据</li> <li>no-store：所有内容都不会缓存。</li></ul> <p>Cache-Control 的值中最常用的为 max-age=xxx**（相对时间）**，缓存本身就是为了数据传输的优化和性能而存在的，所以 no-store 几乎不会使用</p> <h5 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项：</h5> <p>在 HTTP 1.0版本中，Expires字段的<strong>绝对时间</strong>是从服务器获取的，由于请求需要时间，所以浏览器的请求时间与服务器接收到请求所获取的时间是存在误差的，这也导致了缓存命中的误差，在 HTTP 1.1 版本中，因为 Cache-Control 的值 max-age=xxx 中的 xxx 是以秒为单位的<strong>相对时间</strong>，所以在浏览器接收到资源后开始倒计时，规避了 HTTP 1.0 中缓存命中存在误差的缺点，为了兼容低版本 HTTP 协议，正常开发中两种响应头会同时使用，HTTP 1.1 版本的实现优先级高于 HTTP 1.0</p> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <p>设置协商缓存后，第一次访问服务器获取数据时，服务器会将数据和缓存标识一起返回给浏览器，客户端会将数据和标识存入缓存数据库中，下一次请求时，会先去缓存中取出缓存标识发送给服务器进行询问，当服务器数据更改时会更新标识，所以服务器拿到浏览器发来的标识进行对比，相同代表数据未更改，返回304状态码，浏览器会去缓存中获取数据。如果标识不同，代表服务器更改过数据，所以会将新的数据和新的标识返回浏览器，浏览器会将新的数据和标识存入缓存中。</p> <p><img src="C:/Users/ucmed/Desktop/1598968340267.png" alt="1598968340267"></p> <h5 id="两种协商缓存方案"><a href="#两种协商缓存方案" class="header-anchor">#</a> 两种协商缓存方案：</h5> <ul><li><strong>在 HTTP 1.0 版本中，服务器通过 Last-Modified 响应头来设置缓存标识，通常取请求数据的最后修改时间（绝对时间）作为值</strong>。而浏览器将接收到返回的数据和标识存入缓存，再次请求会自动发送 If-Modified-Since 请求头，值为之前返回的最后修改时间（标识），服务器取出 If-Modified-Since 的值与数据的上次修改时间对比，如果上次修改时间大于了 If-Modified-Since 的值，说明被修改过，则通过 Last-Modified 响应头返回新的最后修改时间和新的数据，否则未被修改，返回状态码 304 通知浏览器命中缓存。</li> <li><strong>在 HTTP 1.1 版本中，服务器通过 Etag 响应头来设置缓存标识（唯一标识，像一个指纹一样，生成规则由服务器来决定）</strong>，浏览器接收到数据和唯一标识后存入缓存，下次请求时，通过 If-None-Match 请求头将唯一标识带给服务器，服务器取出唯一标识与之前的标识对比，不同，说明修改过，返回新标识和数据，相同，则返回状态码 304 通知浏览器命中缓存。</li></ul> <h5 id="注意事项-2"><a href="#注意事项-2" class="header-anchor">#</a> 注意事项：</h5> <p>使用协商缓存时 HTTP 1.0 版本还是不太靠谱，假设一个文件增加了一个字符后又删除了，文件相当于没更改，但是最后修改时间变了，会被当作修改处理，本应该命中缓存，服务器却重新发送了数据，因此 HTTP 1.1 中使用的 Etag 唯一标识是根据文件内容或摘要生成的，保证了只要文件内容不变，则一定会命中缓存，为了兼容低版本 HTTP 协议，开发中两种响应头也会同时使用，同样 HTTP 1.1 版本的实现优先级高于 HTTP 1.0</p> <p><img src="C:/Users/ucmed/Desktop/1598967521830.png" alt="1598967521830"></p> <h4 id="缓存使用场景"><a href="#缓存使用场景" class="header-anchor">#</a> 缓存使用场景</h4> <p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p> <ul><li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li> <li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新</li></ul> <h4 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="header-anchor">#</a> 不同刷新的请求执行过程</h4> <ul><li><strong>浏览器地址栏中写入URL，回车</strong>。浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li> <li><strong>F5</strong>就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就战战兢兢的发送一个请求带上If-Modify-since/If-None-Match。</li> <li><strong>Ctrl+F5</strong>告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作</li></ul> <h4 id="调试技巧"><a href="#调试技巧" class="header-anchor">#</a> 调试技巧</h4> <ul><li>使用vue.js devtools、React Developer Tools</li></ul> <p>安装谷歌访问助手 https://segmentfault.com/a/1190000022210711</p> <p>vue-devtool安装</p> <p>1、添加插件 https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd/related</p> <p>2、 允许访问文件网址</p> <p>3、 Vue.js is detected on this page. Devtools inspection is not available beacause it’s in production mode or explicity disabled by the author  引入vue.min.js是不行的，引入vue.js才能使用vue-devtools。（我把vue.min.js 改为 vue.js 后就可以了！！！）如果你是在chrome商店里安装的vue-devtools，那么需要到这个扩展的安装路径下找到manifest.json文件，把其中的”persistent”: false，需改为：true。</p> <ul><li>抓包工具的使用</li></ul> <p>https://zj.lexiangla.com/teams/k100051/docs/79b0fa725c5711eabd650a58ac136690?company_from=zj</p> <ul><li>使用vconsole</li></ul> <p>http://localhost:8090/h5.html/#/healthCardList?hospitalId=1118033010345151344&amp;token=13727732024e8c2d5a7bd1cdce3b712d</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/16/2020, 4:55:25 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/browser/crossDomain.html" class="prev">
        跨域
      </a></span> <span class="next"><a href="/vue/compile.html">
        编译器
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7a7e6d7d.js" defer></script><script src="/assets/js/2.3e29c34d.js" defer></script><script src="/assets/js/8.13f8e95d.js" defer></script>
  </body>
</html>
